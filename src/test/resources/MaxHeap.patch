From e5072e87d1b145f3689644125aa692cc64420256 Mon Sep 17 00:00:00 2001
From: Nikita Ivanov <inik4us@gmail.com>
Date: Tue, 18 Dec 2018 16:47:32 +0300
Subject: [PATCH] Heap tests.

---
 Algorithm/MaxHeap.cs               | 62 +++++++++++-----------
 AlgorithmTests/MaxHeapTests.cs     | 84 +++++++++++++++++++++++++++++-
 AvlTree/AvlTree.cs                 |  9 +---
 AvlTreeTests/AvlTreeDeleteTests.cs |  9 ++++
 QualityControl.sln                 | 12 +++++
 5 files changed, 135 insertions(+), 41 deletions(-)

diff --git a/Algorithm/MaxHeap.cs b/Algorithm/MaxHeap.cs
index 57ec63f..603a4a9 100644
--- a/Algorithm/MaxHeap.cs
+++ b/Algorithm/MaxHeap.cs
@@ -7,7 +7,7 @@ namespace Algorithm
 	public class MaxHeap<T>
 	{
 		private List<T> collection;
-		private Comparer<T> comparer = Comparer<T>.Default;
+		private IComparer<T> comparer = Comparer<T>.Default;
 
 		public int Count => collection.Count;
 		public bool IsEmpty => collection.Count == 0;
@@ -17,17 +17,28 @@ public MaxHeap() : this(0, null)
 
 		}
 
-		public MaxHeap(Comparer<T> comparer) : this(0, comparer)
+		public MaxHeap(IComparer<T> comparer) : this(0, comparer)
 		{
 
 		}
 
-		public MaxHeap(int capacity, Comparer<T> comparer)
+		public MaxHeap(int capacity, IComparer<T> comparer)
 		{
 			collection = new List<T>(capacity);
 			this.comparer = comparer ?? Comparer<T>.Default;
 		}
 
+		public MaxHeap(IReadOnlyList<T> elements, IComparer<T> comparer)
+		{
+			this.comparer = comparer ?? Comparer<T>.Default;
+			Initialize(elements);
+		}
+
+		public MaxHeap(IReadOnlyList<T> elements) : this(elements, null)
+		{
+
+		}
+
 		private void Build()
 		{
 			int lastIndex = collection.Count - 1;
@@ -47,12 +58,17 @@ private void Heapify(int nodeIndex, int lastIndex)
 			int largest = nodeIndex;
 
 			// If collection[left] > collection[nodeIndex]
-			if(left <= lastIndex && comparer.Compare(collection[left], collection[nodeIndex]) > 0)
+			if((left <= lastIndex) && (comparer.Compare(collection[left], collection[nodeIndex]) > 0))
+			{
 				largest = left;
+			}
+				
 
 			// If collection[right] > collection[largest]
-			if(right <= lastIndex && comparer.Compare(collection[right], collection[largest]) > 0)
+			if((right <= lastIndex) && (comparer.Compare(collection[right], collection[largest]) > 0))
+			{
 				largest = right;
+			}
 
 			if(largest != nodeIndex)
 			{
@@ -126,36 +142,20 @@ public void Clear()
 			}
 		}
 
-		public void RebuildHeap()
+		public static MaxHeap<T> Union(MaxHeap<T> a, MaxHeap<T> b)
 		{
-			Build();
-		}
-
-		public T[] ToArray()
-		{
-			return collection.ToArray();
-		}
-
-		public List<T> ToList()
-		{
-			return collection.ToList();
-		}
-
-		public MaxHeap<T> Union(MaxHeap<T> firstMaxHeap, MaxHeap<T> secondMaxHeap)
-		{
-			if(firstMaxHeap == null || secondMaxHeap == null)
-				throw new ArgumentNullException("Illgal union with a null heap.");
-
-			int size = firstMaxHeap.Count + secondMaxHeap.Count;
-			var newHeap = new MaxHeap<T>(size, Comparer<T>.Default);
+			if((a == null) || (b == null))
+			{
+				throw new ArgumentNullException("Illegal union with a null heap.");
+			}
 
-			while(!firstMaxHeap.IsEmpty)
-				newHeap.Add(firstMaxHeap.ExtractMax());
+			int size = a.Count + b.Count;
+			var heap = new MaxHeap<T>(size, Comparer<T>.Default);
 
-			while(!secondMaxHeap.IsEmpty)
-				newHeap.Add(secondMaxHeap.ExtractMax());
+			heap.collection.AddRange(a.collection);
+			heap.collection.AddRange(b.collection);
 
-			return newHeap;
+			return heap;
 		}
 	}
 }
\ No newline at end of file
diff --git a/AlgorithmTests/MaxHeapTests.cs b/AlgorithmTests/MaxHeapTests.cs
index 9ecb988..ce63c0e 100644
--- a/AlgorithmTests/MaxHeapTests.cs
+++ b/AlgorithmTests/MaxHeapTests.cs
@@ -1,5 +1,6 @@
 ï»¿using System;
 using System.Collections.Generic;
+using System.Linq;
 using Xunit;
 using Algorithm;
 
@@ -24,7 +25,17 @@ public void SmallHeap(params int[] elements)
 		}
 
 		[Fact]
-		public void Initialize()
+		public void Removal()
+		{
+			var heap = new MaxHeap<int>();
+			heap.Initialize(new[] { 1 });
+			heap.RemoveMax();
+			Assert.Equal(0, heap.Count);
+			Assert.True(heap.IsEmpty);
+		}
+
+		[Fact]
+		public void InitializeFromList()
 		{
 			var heap = new MaxHeap<int>();
 			var elements = new[] { 1, 2, 3 };
@@ -32,9 +43,78 @@ public void Initialize()
 			AssertSorted(heap, elements);
 		}
 
+		[Fact]
+		public void Peek()
+		{
+			var heap = new MaxHeap<int>();
+			heap.Initialize(new[] { 42, 10, 100 });
+			Assert.Equal(100, heap.Peek());
+		}
+
+		[Fact]
+		public void EmptyPeek()
+		{
+			var heap = new MaxHeap<int>();
+			Assert.Throws<InvalidOperationException>(() => heap.Peek());
+		}
+
+		[Fact]
+		public void EmptyRemove()
+		{
+			var heap = new MaxHeap<int>();
+			Assert.Throws<InvalidOperationException>(() => heap.RemoveMax());
+		}
+
+		[Fact]
+		public void Union()
+		{
+			var a = new[] { 1, 10 };
+			var b = new[] { 4, 9, 0 };
+			var heap = MaxHeap<int>.Union(new MaxHeap<int>(a), new MaxHeap<int>(b));
+			AssertSorted(heap, a.Union(b).ToArray());
+		}
+
+		[Fact]
+		public void NullUnion()
+		{
+			Assert.Throws<ArgumentNullException>(() => MaxHeap<int>.Union(null, new MaxHeap<int>(new[] { 1 })));
+			Assert.Throws<ArgumentNullException>(() => MaxHeap<int>.Union(new MaxHeap<int>(new[] { 1 }), null));
+			Assert.Throws<ArgumentNullException>(() => MaxHeap<int>.Union(null, null));
+		}
+
+		[Fact]
+		public void Clear()
+		{
+			var heap = new MaxHeap<int>(new[] { 12, 2 });
+			heap.Clear();
+			Assert.True(heap.IsEmpty);
+			Assert.Equal(0, heap.Count);
+		}
+
+		struct ReverseComparer : IComparer<int>
+		{
+			public int Compare(int x, int y) => y.CompareTo(x);
+		}
+
+		[Fact]
+		public void CustomComparer()
+		{
+			var heap = new MaxHeap<int>(new[] { 12, 2 }, new ReverseComparer());
+			AssertSorted(heap, new[] { 12, 2 }, new ReverseComparer());
+
+			heap = new MaxHeap<int>(new ReverseComparer());
+			heap.Initialize(new[] { 12, 2 });
+			AssertSorted(heap, new[] { 12, 2 }, new ReverseComparer());
+		}
+
 		private void AssertSorted<T>(MaxHeap<T> heap, T[] elements) where T : IComparable<T>
 		{
-			Array.Sort(elements, (a, b) => b.CompareTo(a));
+			AssertSorted(heap, elements, Comparer<T>.Default);
+		}
+
+		private void AssertSorted<T>(MaxHeap<T> heap, T[] elements, IComparer<T> comparer) where T : IComparable<T>
+		{
+			Array.Sort(elements, (a, b) => comparer.Compare(b, a));
 			foreach(T element in elements)
 			{
 				Assert.Equal(element, heap.ExtractMax());
diff --git a/AvlTree/AvlTree.cs b/AvlTree/AvlTree.cs
index 6f1b3ca..5416e1d 100644
--- a/AvlTree/AvlTree.cs
+++ b/AvlTree/AvlTree.cs
@@ -442,14 +442,7 @@ public bool Delete(TKey key)
 							AvlNode<TKey, TValue> successorParent = successor.Parent;
 							AvlNode<TKey, TValue> successorRight = successor.Right;
 
-							if(successorParent.Left == successor)
-							{
-								successorParent.Left = successorRight;
-							}
-							else
-							{
-								successorParent.Right = successorRight;
-							}
+							successorParent.Left = successorRight;
 
 							if(successorRight != null)
 							{
diff --git a/AvlTreeTests/AvlTreeDeleteTests.cs b/AvlTreeTests/AvlTreeDeleteTests.cs
index 2e95825..4176ed9 100644
--- a/AvlTreeTests/AvlTreeDeleteTests.cs
+++ b/AvlTreeTests/AvlTreeDeleteTests.cs
@@ -246,6 +246,15 @@ public void ExitRebalanceLeftEarly()
 			AssertTreeValid("30+:{20-:{10,25+:{24,~}},35-:{~,36}}", tree);
 		}
 
+		[Fact]
+		public void Foo()
+		{
+			var tree = SetupTree(20, 10, 30, 5, 20, 35, 24, 22, 28, 13);
+			tree.Delete(10);
+			var x = tree.Description();
+			AssertTreeValid(x, tree);
+		}
+
 		private void AssertTreeValid(string description, AvlTree<int, int> tree)
 		{
 			Console.WriteLine(tree.Description());
diff --git a/QualityControl.sln b/QualityControl.sln
index ebede95..310c9c4 100644
--- a/QualityControl.sln
+++ b/QualityControl.sln
@@ -13,6 +13,10 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AvlTree", "AvlTree\AvlTree.
 EndProject
 Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AvlTreeTests", "AvlTreeTests\AvlTreeTests.csproj", "{27874B21-2BF4-485D-8C20-464D442EDA45}"
 EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Algorithm", "Algorithm\Algorithm.csproj", "{6727A150-5D52-427C-8E88-26A800695684}"
+EndProject
+Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AlgorithmTests", "AlgorithmTests\AlgorithmTests.csproj", "{BD051F72-AD79-49E4-884F-62F69D4D333C}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
@@ -39,6 +43,14 @@ Global
 		{27874B21-2BF4-485D-8C20-464D442EDA45}.Debug|Any CPU.Build.0 = Debug|Any CPU
 		{27874B21-2BF4-485D-8C20-464D442EDA45}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{27874B21-2BF4-485D-8C20-464D442EDA45}.Release|Any CPU.Build.0 = Release|Any CPU
+		{6727A150-5D52-427C-8E88-26A800695684}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{6727A150-5D52-427C-8E88-26A800695684}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{6727A150-5D52-427C-8E88-26A800695684}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{6727A150-5D52-427C-8E88-26A800695684}.Release|Any CPU.Build.0 = Release|Any CPU
+		{BD051F72-AD79-49E4-884F-62F69D4D333C}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{BD051F72-AD79-49E4-884F-62F69D4D333C}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{BD051F72-AD79-49E4-884F-62F69D4D333C}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{BD051F72-AD79-49E4-884F-62F69D4D333C}.Release|Any CPU.Build.0 = Release|Any CPU
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
